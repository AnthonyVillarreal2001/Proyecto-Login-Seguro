name: CI/CD Security Pipeline

on:
  pull_request:
    branches:
      - dev
      - test
    types: [opened, synchronize, reopened]
  push:
    branches:
      - test
      - main

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: write
  statuses: write

jobs:
  # ETAPA 1: REVISIÃ“N DE SEGURIDAD CON ML
  security-review:
    name: Security Review with ML Model
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.base_ref == 'test' && github.head_ref == 'dev'
    
    steps:
    - name: Checkout code with PR diff
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        ref: ${{ github.event.pull_request.head.ref }}
    
    - name: Get changed files
      id: changed-files
      uses: tj-actions/changed-files@v39
      with:
        since_last_remote_commit: true
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
    
    - name: Install ML dependencies
      run: |
        pip install joblib scikit-learn==1.5.2 scipy pandas numpy requests jq bc
        pip install -r backend/requirements.txt || true
    
    - name: Setup ML model paths
      run: |
        mkdir -p ml/
        cp -r ml/* ml/ || echo "No hay modelos locales, se usarÃ¡n por defecto"
    
    - name: Send start notification
      if: always()
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        PR_NUMBER=${{ github.event.pull_request.number }}
        PR_TITLE="${{ github.event.pull_request.title }}"
        AUTHOR="${{ github.event.pull_request.user.login }}"
        
        MESSAGE="ğŸš€ *Inicio de RevisiÃ³n de Seguridad*%0A%0AğŸ“‹ *PR:* #${PR_NUMBER}%0AğŸ“ *TÃ­tulo:* ${PR_TITLE}%0AğŸ‘¤ *Autor:* ${AUTHOR}%0AğŸ”€ *De:* dev â†’ test%0Aâ° *Hora:* $(date -u +"%H:%M UTC")"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"
    
    - name: Analyze changed files with ML model
      id: security-scan
      continue-on-error: true
      run: |
        echo "ğŸ” Analizando archivos modificados con modelo ML..."
        
        CHANGED_FILES="${{ steps.changed-files.outputs.all_changed_files }}"
        VULNERABLE_FILES=""
        VULNERABLE_COUNT=0
        SAFE_COUNT=0
        TOTAL_FILES=0
        
        # Filtrar solo archivos de cÃ³digo
        for file in $CHANGED_FILES; do
          if [[ $file =~ \.(js|java|py|c|cs)$ ]]; then
            echo "ğŸ“„ Analizando: $file"
            TOTAL_FILES=$((TOTAL_FILES + 1))
            
            if [[ -f "$file" ]]; then
              RESULT=$(python scripts/security_check.py "$file" 2>/dev/null || echo '{"status":"ERROR"}')
              STATUS=$(echo $RESULT | python -c "import sys, json; print(json.load(sys.stdin)['status'])")
              
              if [ "$STATUS" = "VULNERABLE" ]; then
                echo "âŒ VULNERABLE: $file"
                PROB=$(echo $RESULT | python -c "import sys, json; print(json.load(sys.stdin)['probability'])")
                LANG=$(echo $RESULT | python -c "import sys, json; print(json.load(sys.stdin)['language'])")
                OWASP=$(echo $RESULT | python -c "import sys, json; print(json.load(sys.stdin)['owasp_category'])")
                
                VULNERABLE_FILES="${VULNERABLE_FILES}$file|$PROB|$LANG|$OWASP;"
                VULNERABLE_COUNT=$((VULNERABLE_COUNT + 1))
              else
                echo "âœ… SAFE: $file"
                SAFE_COUNT=$((SAFE_COUNT + 1))
              fi
            fi
          fi
        done
        
        # Salida para el siguiente paso
        echo "vulnerable_count=$VULNERABLE_COUNT" >> $GITHUB_OUTPUT
        echo "safe_count=$SAFE_COUNT" >> $GITHUB_OUTPUT
        echo "total_files=$TOTAL_FILES" >> $GITHUB_OUTPUT
        echo "vulnerable_files=$VULNERABLE_FILES" >> $GITHUB_OUTPUT
        
        if [ $VULNERABLE_COUNT -gt 0 ]; then
          echo "âŒ Se encontraron $VULNERABLE_COUNT archivos vulnerables"
          exit 1
        else
          echo "âœ… Todos los archivos son seguros ($SAFE_COUNT/$TOTAL_FILES)"
        fi
    
    - name: Send security result notification
      if: always()
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        PR_NUMBER=${{ github.event.pull_request.number }}
        
        if [ ${{ steps.security-scan.outcome }} == 'success' ]; then
          MESSAGE="âœ… *RevisiÃ³n de Seguridad COMPLETADA*%0A%0AğŸ“Š *Resultado:* SEGURO%0AğŸ“ *Archivos analizados:* ${{ steps.security-scan.outputs.total_files }}%0Aâœ… *Seguros:* ${{ steps.security-scan.outputs.safe_count }}%0Aâš ï¸ *Vulnerables:* 0%0AğŸ”„ *Continuando con merge automÃ¡tico...*"
        else
          VULNERABLE_COUNT=${{ steps.security-scan.outputs.vulnerable_count }}
          VULNERABLE_FILES="${{ steps.security-scan.outputs.vulnerable_files }}"
          
          MESSAGE="ğŸš¨ *RevisiÃ³n de Seguridad COMPLETADA*%0A%0AğŸ“Š *Resultado:* VULNERABLE%0AğŸ“ *Archivos analizados:* ${{ steps.security-scan.outputs.total_files }}%0AâŒ *Vulnerables:* ${VULNERABLE_COUNT}%0A%0A*ğŸ“‹ Archivos vulnerables:*%0A"
          
          IFS=';' read -ra FILES <<< "$VULNERABLE_FILES"
          for item in "${FILES[@]}"; do
            if [ ! -z "$item" ]; then
              IFS='|' read -r FILE PROB LANG OWASP <<< "$item"
              PERCENT=$(echo "scale=0; $PROB * 100" | bc)
              MESSAGE="${MESSAGE}%0AğŸ“„ *${FILE}*%0A  ğŸ”¸ Prob: ${PERCENT}%%%0A  ğŸ”¸ Lang: ${LANG}%0A  ğŸ”¸ OWASP: ${OWASP}%0A"
            fi
          done
          
          MESSAGE="${MESSAGE}%0AğŸš« *Merge bloqueado*%0AğŸ“ *Creando issue automÃ¡tica...*"
        fi
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"
    
    - name: Create issue if vulnerable
      if: failure()
      uses: peter-evans/create-issue-from-file@v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        title: "ğŸš¨ fixing-required: Vulnerabilidades detectadas en PR #${{ github.event.pull_request.number }}"
        content-filepath: .github/workflows/templates/security-issue.md
        labels: fixing-required,security,vulnerability,automated
    
    - name: Block PR if vulnerable
      if: failure()
      run: |
        echo "âŒ Vulnerabilidades detectadas. Bloqueando merge del PR."
        exit 1
    
    outputs:
      security-passed: ${{ steps.security-scan.outcome == 'success' }}

  # ETAPA 2: MERGE AUTOMÃTICO A TEST + PRUEBAS
  merge-and-test:
    name: Merge to Test and Run Tests
    runs-on: ubuntu-latest
    needs: security-review
    if: needs.security-review.outputs.security-passed == 'true'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Configure Git
      run: |
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "actions@github.com"
    
    - name: Merge dev into test (auto-merge)
      run: |
        echo "ğŸ”„ Mergeando dev â†’ test..."
        
        # Asegurarse de tener las ramas actualizadas
        git fetch origin dev test
        
        # Hacer merge
        git checkout test
        git merge --no-ff origin/dev -m "ğŸ¤– Auto-merge devâ†’test [PR#${{ github.event.pull_request.number }}]"
        git push origin test
        
        echo "âœ… Merge completado exitosamente"
    
    - name: Send merge notification
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        MESSAGE="âœ… *Merge AutomÃ¡tico Realizado*%0A%0AğŸ”€ *Ramas:* dev â†’ test%0AğŸ“‹ *PR:* #${{ github.event.pull_request.number }}%0AğŸ‘¤ *Autor:* ${{ github.event.pull_request.user.login }}%0Aâ° *Hora:* $(date -u +"%H:%M UTC")%0A%0AğŸ§ª *Ejecutando pruebas unitarias...*"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"
    
    - name: Setup Node.js for frontend tests
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Install frontend dependencies
      working-directory: ./frontend
      run: |
        npm ci
        npm install --save-dev jest jest-environment-jsdom
    
    - name: Run frontend tests
      id: frontend-tests
      working-directory: ./frontend
      continue-on-error: true
      run: |
        echo "ğŸ§ª Ejecutando pruebas del frontend..."
        
        # Configurar variables de entorno para pruebas
        export REACT_APP_API_URL=http://localhost:5000
        
        # Ejecutar pruebas
        npm test -- --passWithNoTests --watchAll=false --testPathPattern=".*\.test\.js$" 2>&1 | tee test-output.log
        
        # Extraer resultados
        if grep -q "Test Suites:.*passed" test-output.log; then
          echo "âœ… Pruebas del frontend pasaron"
          echo "result=passed" >> $GITHUB_OUTPUT
        else
          echo "âŒ Pruebas del frontend fallaron"
          echo "result=failed" >> $GITHUB_OUTPUT
          exit 1
        fi
    
    - name: Setup backend environment
      working-directory: ./backend
      run: |
        echo "âš™ï¸ Configurando backend para pruebas..."
        
        # Instalar dependencias
        npm ci || npm install
        
        # Crear archivo de configuraciÃ³n para tests
        cat > .env.test << EOF
        NODE_ENV=test
        DATABASE_URL=postgresql://test:test@localhost:5432/test_db
        JWT_SECRET=test_secret_123
        EOF
    
    - name: Run backend tests
      id: backend-tests
      working-directory: ./backend
      continue-on-error: true
      run: |
        echo "ğŸ§ª Ejecutando pruebas del backend..."
        
        # Configurar entorno
        export NODE_ENV=test
        
        # Ejecutar pruebas
        npm test -- --testTimeout=10000 2>&1 | tee test-output.log
        
        # Verificar resultados
        if grep -q "Test Suites:.*passed" test-output.log || grep -q "PASS" test-output.log; then
          echo "âœ… Pruebas del backend pasaron"
          echo "result=passed" >> $GITHUB_OUTPUT
        else
          echo "âŒ Pruebas del backend fallaron"
          echo "result=failed" >> $GITHUB_OUTPUT
          exit 1
        fi
    
    - name: Send test results notification
      if: always()
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        FRONTEND_RESULT="${{ steps.frontend-tests.outcome }}"
        BACKEND_RESULT="${{ steps.backend-tests.outcome }}"
        
        if [ "$FRONTEND_RESULT" == "success" ] && [ "$BACKEND_RESULT" == "success" ]; then
          MESSAGE="âœ… *Pruebas Completadas*%0A%0AğŸ§ª *Resultado:* TODO PASÃ“%0Aâš›ï¸ Frontend: âœ…%0Aâš™ï¸ Backend: âœ…%0A%0AğŸš€ *Listo para producciÃ³n...*"
          EMOJI="âœ…"
          LABEL="tests-passed"
        else
          MESSAGE="âŒ *Pruebas Fallidas*%0A%0AğŸ§ª *Resultado:* FALLAS DETECTADAS%0Aâš›ï¸ Frontend: $FRONTEND_RESULT%0Aâš™ï¸ Backend: $BACKEND_RESULT%0A%0AğŸš« *Merge bloqueado*%0AğŸ”§ *Revisar errores de pruebas*"
          EMOJI="âŒ"
          LABEL="tests-failed"
        fi
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"
    
    - name: Add label based on test results
      if: always()
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const prNumber = ${{ github.event.pull_request.number }};
          const frontendPassed = '${{ steps.frontend-tests.outcome }}' === 'success';
          const backendPassed = '${{ steps.backend-tests.outcome }}' === 'success';
          
          if (frontendPassed && backendPassed) {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: ['tests-passed']
            });
          } else {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: ['tests-failed']
            });
          }
    
    outputs:
      tests-passed: ${{ steps.frontend-tests.outcome == 'success' && steps.backend-tests.outcome == 'success' }}

  # ETAPA 3: MERGE A MAIN Y DESPLIEGUE
  merge-and-deploy:
    name: Merge to Main and Deploy to Production
    runs-on: ubuntu-latest
    needs: merge-and-test
    if: needs.merge-and-test.outputs.tests-passed == 'true'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Configure Git
      run: |
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "actions@github.com"
    
    - name: Merge test into main
      run: |
        echo "ğŸš€ Mergeando test â†’ main para despliegue..."
        
        # Actualizar ramas
        git fetch origin test main
        
        # Hacer merge
        git checkout main
        git merge --no-ff origin/test -m "ğŸš€ Deploy to production [PR#${{ github.event.pull_request.number }}]"
        git push origin main
        
        echo "âœ… Merge a main completado"
    
    - name: Send merge to main notification
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        MESSAGE="ğŸš€ *Merge a Main Realizado*%0A%0AğŸ¯ *Ramas:* test â†’ main%0AğŸ“‹ *PR:* #${{ github.event.pull_request.number }}%0AğŸ·ï¸ *VersiÃ³n:* $(git describe --tags --always)%0A%0AğŸ³ *Iniciando despliegue en producciÃ³n...*"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"
    
    - name: Setup Docker
      uses: docker/setup-buildx-action@v2
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and push Backend Docker image
      run: |
        echo "ğŸ³ Construyendo imagen Docker del backend..."
        
        # Crear Dockerfile para backend si no existe
        if [ ! -f "backend/Dockerfile" ]; then
          cat > backend/Dockerfile << EOF
        FROM node:18-alpine
        WORKDIR /app
        COPY package*.json ./
        RUN npm ci --only=production
        COPY . .
        EXPOSE 5000
        CMD ["node", "index.js"]
        EOF
        fi
        
        # Construir y etiquetar imagen
        docker build -t ${{ secrets.DOCKER_USERNAME }}/secure-app-backend:latest ./backend
        docker push ${{ secrets.DOCKER_USERNAME }}/secure-app-backend:latest
    
    - name: Build and push Frontend Docker image
      run: |
        echo "ğŸ³ Construyendo imagen Docker del frontend..."
        
        # Crear Dockerfile para frontend si no existe
        if [ ! -f "frontend/Dockerfile" ]; then
          cat > frontend/Dockerfile << EOF
        FROM node:18-alpine as build
        WORKDIR /app
        COPY package*.json ./
        RUN npm ci
        COPY . .
        RUN npm run build
        
        FROM nginx:alpine
        COPY --from=build /app/build /usr/share/nginx/html
        COPY nginx.conf /etc/nginx/conf.d/default.conf
        EXPOSE 80
        CMD ["nginx", "-g", "daemon off;"]
        EOF
        fi
        
        # Crear configuraciÃ³n nginx
        cat > frontend/nginx.conf << EOF
        server {
            listen 80;
            server_name localhost;
            
            location / {
                root /usr/share/nginx/html;
                index index.html index.htm;
                try_files \$uri \$uri/ /index.html;
            }
            
            location /api/ {
                proxy_pass http://backend:5000/;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host \$host;
                proxy_cache_bypass \$http_upgrade;
            }
        }
        EOF
        
        # Construir y etiquetar imagen
        docker build -t ${{ secrets.DOCKER_USERNAME }}/secure-app-frontend:latest ./frontend
        docker push ${{ secrets.DOCKER_USERNAME }}/secure-app-frontend:latest
    
    - name: Deploy to Render (Backend)
      if: success()
      env:
        RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
      run: |
        echo "ğŸš€ Desplegando backend en Render..."
        
        # Usar la API de Render para actualizar el servicio
        SERVICE_ID=${{ secrets.RENDER_BACKEND_SERVICE_ID }}
        
        curl -X POST "https://api.render.com/v1/services/${SERVICE_ID}/deploys" \
          -H "Authorization: Bearer ${RENDER_API_KEY}" \
          -H "Content-Type: application/json" \
          -d '{
            "clearCache": "do_not_clear"
          }'
    
    - name: Deploy to Vercel (Frontend)
      if: success()
      env:
        VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
        VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
        VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      run: |
        echo "ğŸš€ Desplegando frontend en Vercel..."
        
        # Instalar CLI de Vercel
        npm install -g vercel
        
        # Desplegar desde el directorio frontend
        cd frontend
        vercel --prod --token ${VERCEL_TOKEN} --confirm
        
        # Obtener URL del despliegue
        DEPLOYMENT_URL=$(vercel --token ${VERCEL_TOKEN} --scope ${VERCEL_ORG_ID} | grep -o 'https://[^ ]*')
        echo "DEPLOYMENT_URL=${DEPLOYMENT_URL}" >> $GITHUB_ENV
    
    - name: Send deployment success notification
      if: success()
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        MESSAGE="ğŸ‰ *Â¡Despliegue Exitoso!*%0A%0Aâœ… *Estado:* PRODUCCIÃ“N ACTIVA%0AğŸ—ï¸ *Backend:* Render%0AğŸ¨ *Frontend:* Vercel%0AğŸ³ *ImÃ¡genes:* Docker Hub%0AğŸ”— *URL Frontend:* ${{ env.DEPLOYMENT_URL }}%0A%0AğŸ“‹ *PR:* #${{ github.event.pull_request.number }}%0AğŸ‘¤ *Autor:* ${{ github.event.pull_request.user.login }}%0Aâ° *Hora:* $(date -u +"%H:%M UTC")"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"
    
    - name: Send deployment failure notification
      if: failure()
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        MESSAGE="âŒ *Â¡Despliegue Fallido!*%0A%0AğŸš¨ *Estado:* ERROR EN PRODUCCIÃ“N%0AğŸ“‹ *PR:* #${{ github.event.pull_request.number }}%0AğŸ‘¤ *Autor:* ${{ github.event.pull_request.user.login }}%0AğŸ”§ *AcciÃ³n:* Revisar logs de GitHub Actions%0Aâ° *Hora:* $(date -u +"%H:%M UTC")"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"

  # JOB PARA DEPLOY DIRECTOS A MAIN (push a main)
  direct-deploy:
    name: Direct Deploy to Production
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Send direct deploy notification
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        COMMIT_MSG=$(git log -1 --pretty=%B)
        COMMIT_AUTHOR=$(git log -1 --pretty=%an)
        
        MESSAGE="ğŸš€ *Deploy Directo a ProducciÃ³n*%0A%0AğŸ“Œ *Commit:* ${COMMIT_MSG:0:50}...%0AğŸ‘¤ *Autor:* ${COMMIT_AUTHOR}%0AğŸ·ï¸ *SHA:* ${GITHUB_SHA:0:8}%0A%0AğŸ³ *Iniciando despliegue...*"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"
    
    - name: Deploy to Production
      run: |
        # Reutilizar los pasos de despliegue del job anterior
        echo "ğŸš€ Desplegando versiÃ³n ${GITHUB_SHA:0:8} a producciÃ³n..."
        # Los pasos de Docker y despliegue serÃ­an los mismos