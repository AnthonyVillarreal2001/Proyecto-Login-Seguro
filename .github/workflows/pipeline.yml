name: Full CI/CD Pipeline

on:
  push:
    branches: [dev]
  workflow_run:
    workflows: ["Security and Merge Pipeline"]
    types: [completed]
    branches: [test]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  security-analysis:
    name: ğŸ” Security Analysis on Dev
    if: github.ref == 'refs/heads/dev'
    runs-on: ubuntu-latest
    
    outputs:
      is_safe: ${{ steps.scan.outputs.is_safe }}
      vulnerable_details: ${{ steps.scan.outputs.vulnerable_details }}
      scanned_count: ${{ steps.scan.outputs.scanned_count }}

    steps:
    - name: ğŸ“¦ Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: ğŸ Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"

    - name: ğŸ“¥ Install Python dependencies
      run: |
        pip install -r requirements.txt || true
        pip install joblib datasets scikit-learn==1.5.2 scipy requests pandas jq

    - name: ğŸ” Security Scan All Files
      id: scan
      run: |
        echo "ğŸ”„ Iniciando escaneo de seguridad completo..."
        
        # Encontrar todos los archivos a analizar
        echo "ğŸ” Buscando archivos JavaScript..."
        JS_FILES=$(find . -name "*.js" -not -path "*/node_modules/*" -not -path "*/.next/*" -not -path "*/.venv/*" 2>/dev/null || true)
        
        echo "ğŸ” Buscando archivos Python..."
        PY_FILES=$(find . -name "*.py" -not -path "*/node_modules/*" -not -path "*/.venv/*" -not -path "*/scripts/*" 2>/dev/null || true)
        
        echo "ğŸ” Buscando archivos Java..."
        JAVA_FILES=$(find . -name "*.java" -not -path "*/node_modules/*" -not -path "*/.venv/*" 2>/dev/null || true)
        
        # Combinar todos los archivos
        ALL_FILES=""
        for file in $JS_FILES $PY_FILES $JAVA_FILES; do
          if [ -f "$file" ]; then
            ALL_FILES="${ALL_FILES}${file}"$'\n'
          fi
        done
        
        echo "ğŸ“‹ Archivos a analizar:"
        echo "$ALL_FILES" | while read file; do
          if [ -n "$file" ]; then
            echo "   - $file"
          fi
        done
        
        FAILED=0
        VULNERABLE_FILES=""
        SCANNED_COUNT=0
        
        # Analizar cada archivo
        while IFS= read -r file; do
          if [ -n "$file" ] && [ -f "$file" ]; then
            SCANNED_COUNT=$((SCANNED_COUNT + 1))
            echo ""
            echo "ğŸ”¬ Analizando ($SCANNED_COUNT): $file"
            
            RESULT=$(python scripts/security_check.py "$file" 2>/dev/null || echo '{"status":"ERROR"}')
            echo "Resultado crudo: $RESULT"
            
            STATUS=$(echo "$RESULT" | python3 -c "import sys, json; print(json.load(sys.stdin).get('status', 'ERROR'))" 2>/dev/null || echo "ERROR")
            echo "Estado: $STATUS"
            
            if [ "$STATUS" = "VULNERABLE" ]; then
              echo "âŒ VULNERABLE: $file"
              
              PROB=$(echo "$RESULT" | python3 -c "import sys, json; print(json.load(sys.stdin).get('probability', 0))" 2>/dev/null || echo "0")
              LANG=$(echo "$RESULT" | python3 -c "import sys, json; print(json.load(sys.stdin).get('language', 'Unknown'))" 2>/dev/null || echo "Unknown")
              FUNCS=$(echo "$RESULT" | python3 -c "import sys, json; print(json.load(sys.stdin).get('dangerous_functions', '[]'))" 2>/dev/null || echo "[]")
              OWASP=$(echo "$RESULT" | python3 -c "import sys, json; print(json.load(sys.stdin).get('owasp_category', 'Unknown'))" 2>/dev/null || echo "Unknown")
              
              VULNERABLE_FILES="${VULNERABLE_FILES}FILE:${file}|PROB:${PROB}|LANG:${LANG}|FUNCS:${FUNCS}|OWASP:${OWASP};"
              FAILED=1
            elif [ "$STATUS" = "SAFE" ]; then
              echo "âœ… SAFE: $file"
            else
              echo "âš ï¸  ERROR analizando: $file"
            fi
          fi
        done <<< "$ALL_FILES"
        
        echo ""
        echo "ğŸ“Š Resumen del escaneo:"
        echo "   Total archivos: $SCANNED_COUNT"
        echo "   Vulnerables: $(echo "$VULNERABLE_FILES" | tr ';' '\n' | grep -c "FILE:")"
        
        echo "scanned_count=$SCANNED_COUNT" >> $GITHUB_OUTPUT
        echo "vulnerable_details=$VULNERABLE_FILES" >> $GITHUB_OUTPUT
        
        if [ $FAILED -eq 1 ]; then
          echo "is_safe=false" >> $GITHUB_OUTPUT
          echo "âŒ Â¡Vulnerabilidades detectadas! Bloqueando merge..."
          exit 1
        else
          echo "is_safe=true" >> $GITHUB_OUTPUT
          echo "âœ… Â¡Todos los archivos son seguros! Procediendo..."
        fi

    - name: ğŸ“Š Report Scan Results
      run: |
        echo "ğŸ“ˆ RESUMEN FINAL DEL ESCANEO:"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸ“Š Archivos analizados: ${{ steps.scan.outputs.scanned_count }}"
        echo "ğŸ›¡ï¸ Estado: ${{ steps.scan.outputs.is_safe == 'true' && 'âœ… SEGURO' || 'âŒ VULNERABLE' }}"
        
        if [ "${{ steps.scan.outputs.vulnerable_details }}" != "" ]; then
          echo ""
          echo "ğŸš¨ ARCHIVOS VULNERABLES DETECTADOS:"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "${{ steps.scan.outputs.vulnerable_details }}" | tr ';' '\n' | while read -r item; do
            if [ -n "$item" ]; then
              FILE=$(echo "$item" | sed 's/.*FILE:\([^|]*\).*/\1/')
              echo "   ğŸ“„ $FILE"
            fi
          done
        fi

    - name: ğŸš¨ Send Telegram Alert on Failure
      if: failure()
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        SCANNED_COUNT="${{ steps.scan.outputs.scanned_count }}"
        DETAILS="${{ steps.scan.outputs.vulnerable_details }}"
        
        MESSAGE="ğŸš¨ *Auto-Merge BLOQUEADO*%0A%0A"
        MESSAGE="${MESSAGE}âŒ *Estado:* VULNERABLE%0A"
        MESSAGE="${MESSAGE}ğŸ“‚ *Rama:* dev%0A"
        MESSAGE="${MESSAGE}ğŸš« *AcciÃ³n:* Merge bloqueado%0A%0A"
        MESSAGE="${MESSAGE}*ğŸ“Š Resumen del escaneo:*%0A"
        MESSAGE="${MESSAGE}ğŸ” Archivos analizados: ${SCANNED_COUNT}%0A"
        
        # Contar vulnerabilidades
        VULN_COUNT=0
        if [ -n "$DETAILS" ]; then
          VULN_COUNT=$(echo "$DETAILS" | tr ';' '\n' | grep -c "FILE:")
        fi
        
        MESSAGE="${MESSAGE}âš ï¸ Vulnerabilidades: ${VULN_COUNT}%0A%0A"
        
        if [ $VULN_COUNT -gt 0 ]; then
          MESSAGE="${MESSAGE}*ğŸ“‹ Archivos vulnerables:*%0A"
          
          IFS=';' read -ra FILES <<< "$DETAILS"
          for item in "${FILES[@]}"; do
            if [ ! -z "$item" ]; then
              FILE=$(echo "$item" | sed 's/.*FILE:\([^|]*\).*/\1/')
              PROB=$(echo "$item" | sed 's/.*PROB:\([^|]*\).*/\1/')
              LANG=$(echo "$item" | sed 's/.*LANG:\([^|]*\).*/\1/')
              
              # Calcular porcentaje
              PERCENT=$(echo "$PROB * 100" | bc 2>/dev/null || echo "0")
              PERCENT_INT=$(printf "%.0f" $PERCENT 2>/dev/null || echo "0")
              
              MESSAGE="${MESSAGE}%0AğŸ“„ \`$(basename "$FILE")\`%0A"
              MESSAGE="${MESSAGE}   ğŸ”¤ ${LANG} | âš ï¸ ${PERCENT_INT}%%%0A"
            fi
          done
        fi
        
        MESSAGE="${MESSAGE}%0AğŸ”— *Revisa los logs para mÃ¡s detalles*"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"

    - name: âœ… Send Telegram Success Notification
      if: success()
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        SCANNED_COUNT="${{ steps.scan.outputs.scanned_count }}"
        
        MESSAGE="âœ… *Escaneo de Seguridad COMPLETADO*%0A%0A"
        MESSAGE="${MESSAGE}ğŸ“‚ *Rama:* dev%0A"
        MESSAGE="${MESSAGE}ğŸ“Š *Archivos analizados:* ${SCANNED_COUNT}%0A"
        MESSAGE="${MESSAGE}ğŸ›¡ï¸ *Estado:* TODOS SEGUROS%0A%0A"
        MESSAGE="${MESSAGE}ğŸ”„ *Siguiente paso:* Mergeando a test"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"

  merge-to-test:
    name: ğŸ”€ Merge Dev to Test
    needs: security-analysis
    runs-on: ubuntu-latest
    if: needs.security-analysis.outputs.is_safe == 'true' && github.ref == 'refs/heads/dev'

    steps:
    - name: ğŸ“¦ Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: âš™ï¸ Configure Git
      run: |
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "actions@github.com"

    - name: ğŸ”€ Merge dev into test
      run: |
        echo "ğŸ”„ Mergeando dev a test..."
        
        # Obtener el Ãºltimo commit de dev
        git fetch origin dev
        git fetch origin test
        
        # Crear mensaje de commit
        COMMIT_MSG="ğŸ”€ Auto-merge: dev â†’ test [Security Check Passed]
        
        âœ… Security Analysis Results:
        - Archivos analizados: ${{ needs.security-analysis.outputs.scanned_count }}
        - Vulnerabilidades: 0
        - Estado: SEGURO
        
        ğŸ” Pipeline ejecutado automÃ¡ticamente
        SHA: $(git rev-parse origin/dev)
        Fecha: $(date)
        
        ğŸ·ï¸ Tags: security-checked, ready-for-testing"
        
        # Hacer el merge
        git checkout test
        git pull origin test
        git merge --no-ff origin/dev -m "$COMMIT_MSG"
        
        # Push a test
        echo "ğŸ“¤ Haciendo push a test..."
        git push origin test
        
        echo "âœ… Merge completado exitosamente!"
        echo "SHA del merge: $(git rev-parse HEAD)"

    - name: ğŸ“¢ Notify Merge Success
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        MESSAGE="âœ… *Merge Completado*%0A%0A"
        MESSAGE="${MESSAGE}ğŸ”„ *De:* dev%0A"
        MESSAGE="${MESSAGE}ğŸ“‚ *A:* test%0A"
        MESSAGE="${MESSAGE}ğŸ“Š *Archivos analizados:* ${{ needs.security-analysis.outputs.scanned_count }}%0A"
        MESSAGE="${MESSAGE}ğŸ›¡ï¸ *Estado:* TODOS SEGUROS%0A%0A"
        MESSAGE="${MESSAGE}ğŸ§ª *Siguiente paso:* Ejecutando pruebas unitarias"
        MESSAGE="${MESSAGE}%0AğŸ”— *Los tests se ejecutarÃ¡n automÃ¡ticamente*"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"

  # Este workflow se activa cuando hay push a test (despuÃ©s del merge)
  run-tests-on-test:
    name: ğŸ§ª Run Tests on Test Branch
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/test'
    
    strategy:
      matrix:
        test-type: [backend, frontend]

    steps:
    - name: ğŸ“¦ Checkout repository
      uses: actions/checkout@v3
      with:
        ref: test

    - name: ğŸ§ª Backend Tests
      if: matrix.test-type == 'backend'
      run: |
        echo "ğŸ§ª INICIANDO PRUEBAS BACKEND"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        
        # Buscar backend
        if [ -d "backend" ]; then
          echo "ğŸ“ Backend encontrado en: backend/"
          cd backend
        elif [ -f "package.json" ] && ( [ -f "index.js" ] || [ -f "server.js" ] || [ -f "app.js" ] ); then
          echo "ğŸ“ Backend encontrado en raÃ­z"
        else
          echo "âš ï¸ No se encontrÃ³ backend"
          echo "âœ… Saltando pruebas backend"
          exit 0
        fi
        
        echo "ğŸ“¦ Instalando dependencias..."
        npm ci --silent 2>/dev/null || npm install --silent
        
        echo "ğŸš€ Ejecutando pruebas..."
        if grep -q '"test"' package.json; then
          npm test 2>&1 | tee test-output.log
          TEST_RESULT=${PIPESTATUS[0]}
          
          if [ $TEST_RESULT -eq 0 ]; then
            echo "âœ… BACKEND TESTS PASSED"
          else
            echo "âŒ BACKEND TESTS FAILED"
            echo "ğŸ“„ Ãšltimas lÃ­neas del log:"
            tail -20 test-output.log
            exit 1
          fi
        else
          echo "âš ï¸ No hay script 'test' en package.json"
          echo "âœ… Saltando pruebas backend"
        fi

    - name: ğŸ§ª Frontend Tests
      if: matrix.test-type == 'frontend'
      run: |
        echo "ğŸ§ª INICIANDO PRUEBAS FRONTEND"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        
        # Buscar frontend
        if [ -d "frontend" ]; then
          echo "ğŸ“ Frontend encontrado en: frontend/"
          cd frontend
        elif [ -d "client" ]; then
          echo "ğŸ“ Frontend encontrado en: client/"
          cd client
        elif [ -f "package.json" ] && (grep -q "react-scripts" package.json || grep -q "next" package.json); then
          echo "ğŸ“ Frontend encontrado en raÃ­z"
        else
          echo "âš ï¸ No se encontrÃ³ frontend React"
          echo "âœ… Saltando pruebas frontend"
          exit 0
        fi
        
        echo "ğŸ“¦ Instalando dependencias..."
        npm ci --silent 2>/dev/null || npm install --silent
        
        echo "ğŸš€ Ejecutando pruebas..."
        if grep -q '"test"' package.json; then
          # Modo CI para React
          CI=true npm test -- --watchAll=false --passWithNoTests 2>&1 | tee test-output.log
          TEST_RESULT=${PIPESTATUS[0]}
          
          if [ $TEST_RESULT -eq 0 ]; then
            echo "âœ… FRONTEND TESTS PASSED"
          else
            echo "âŒ FRONTEND TESTS FAILED"
            echo "ğŸ“„ Ãšltimas lÃ­neas del log:"
            tail -20 test-output.log
            exit 1
          fi
        else
          echo "âš ï¸ No hay script 'test' en package.json"
          echo "âœ… Saltando pruebas frontend"
        fi

  merge-to-main:
    name: ğŸš€ Merge Test to Main (After Tests)
    needs: run-tests-on-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/test' && needs.run-tests-on-test.result == 'success'

    steps:
    - name: ğŸ“¦ Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        ref: test

    - name: âš™ï¸ Configure Git
      run: |
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "actions@github.com"

    - name: ğŸ”€ Merge test into main
      run: |
        echo "ğŸš€ INICIANDO MERGE A MAIN"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        
        # Obtener informaciÃ³n del commit actual en test
        CURRENT_SHA=$(git rev-parse HEAD)
        CURRENT_COMMIT_MSG=$(git log -1 --pretty=%B)
        
        # Fetch todas las ramas
        git fetch origin main
        git fetch origin test
        
        # Crear mensaje detallado
        MERGE_MSG="ğŸš€ Auto-merge: test â†’ main [All Checks Passed]
        
        ğŸ“Š RESULTADOS DEL PIPELINE:
        
        ğŸ” SECURITY ANALYSIS:
        - Estado: âœ… COMPLETADO
        - Vulnerabilidades: 0
        
        ğŸ§ª UNIT TESTS:
        - Backend: âœ… PASSED
        - Frontend: âœ… PASSED
        - Estado general: âœ… TODAS LAS PRUEBAS EXITOSAS
        
        ğŸ“¦ DEPLOYMENT INFO:
        - Rama origen: test
        - Rama destino: main
        - Commit SHA: ${CURRENT_SHA:0:8}
        - Pipeline ejecutado: $(date '+%Y-%m-%d %H:%M:%S')
        
        ğŸ”§ Pipeline ID: ${{ github.run_id }}
        ğŸ·ï¸ Tags: production-ready, tested, secure
        
        ğŸ“ Ãšltimo commit en test:
        ${CURRENT_COMMIT_MSG}"
        
        # Realizar el merge
        echo "ğŸ”„ Cambiando a main..."
        git checkout main
        git pull origin main
        
        echo "ğŸ”€ Mergeando test a main..."
        git merge --no-ff test -m "$MERGE_MSG"
        
        echo "ğŸ“¤ Haciendo push a main..."
        git push origin main
        
        # Crear tag
        TAG_NAME="release-$(date '+%Y%m%d-%H%M%S')"
        echo "ğŸ·ï¸ Creando tag: $TAG_NAME"
        git tag -a "$TAG_NAME" -m "Production release - Pipeline #${{ github.run_id }}"
        git push origin "$TAG_NAME"
        
        echo "âœ… MERGE COMPLETADO EXITOSAMENTE!"
        echo "ğŸ”— Tag creado: $TAG_NAME"
        echo "ğŸ“Š SHA: $(git rev-parse HEAD)"

    - name: ğŸ‰ Deploy Notification
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        TAG_NAME="release-$(date '+%Y%m%d-%H%M%S')"
        
        MESSAGE="ğŸ‰ *Â¡DESPLIEGUE EXITOSO!*%0A%0A"
        MESSAGE="${MESSAGE}ğŸš€ *Pipeline CI/CD COMPLETADO*%0A"
        MESSAGE="${MESSAGE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%0A%0A"
        MESSAGE="${MESSAGE}ğŸ“Š *RESUMEN FINAL:*%0A"
        MESSAGE="${MESSAGE}âœ… *Security Analysis:* COMPLETADO%0A"
        MESSAGE="${MESSAGE}âœ… *Pruebas Unitarias:* COMPLETADAS%0A"
        MESSAGE="${MESSAGE}   â”œâ”€ Backend: âœ… PASSED%0A"
        MESSAGE="${MESSAGE}   â””â”€ Frontend: âœ… PASSED%0A%0A"
        MESSAGE="${MESSAGE}ğŸ“¦ *DESPLIEGUE:*%0A"
        MESSAGE="${MESSAGE}   â”œâ”€ Rama origen: test%0A"
        MESSAGE="${MESSAGE}   â”œâ”€ Rama destino: main%0A"
        MESSAGE="${MESSAGE}   â”œâ”€ SHA: ${GITHUB_SHA:0:8}%0A"
        MESSAGE="${MESSAGE}   â””â”€ Tag: ${TAG_NAME}%0A%0A"
        MESSAGE="${MESSAGE}ğŸ *ESTADO:* âœ… PRODUCCIÃ“N LISTA%0A"
        MESSAGE="${MESSAGE}%0AğŸ”— *Commit:* $GITHUB_SERVER_URL/$GITHUB_REPOSITORY/commit/$GITHUB_SHA"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"

    - name: ğŸ“‹ Create Release Summary
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG_NAME="release-$(date '+%Y%m%d-%H%M%S')"
        
        RELEASE_BODY="# ğŸš€ Release $TAG_NAME
        
        ## ğŸ“Š Pipeline Summary
        
        ### ğŸ” Security Analysis
        - Status: âœ… PASSED
        - Files Scanned: ${{ needs.security-analysis.outputs.scanned_count }}
        - Vulnerabilities: 0
        
        ### ğŸ§ª Unit Tests
        - Backend: âœ… PASSED
        - Frontend: âœ… PASSED
        
        ### ğŸ“¦ Deployment
        - From Branch: test
        - To Branch: main
        - Pipeline Run: #${{ github.run_id }}
        - Timestamp: $(date)
        
        ## ğŸ”— Links
        - Workflow Run: $GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID
        - Commit: $GITHUB_SERVER_URL/$GITHUB_REPOSITORY/commit/$GITHUB_SHA
        
        ## ğŸ·ï¸ Tags
        production-ready, secure, tested"
        
        # Crear release en GitHub
        gh release create "$TAG_NAME" \
          --title "Production Release $TAG_NAME" \
          --notes "$RELEASE_BODY" \
          --target main

  handle-failure:
    name: ğŸ”„ Handle Pipeline Failure
    runs-on: ubuntu-latest
    if: failure() && (github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/test')
    
    steps:
    - name: ğŸ“¦ Checkout repository
      uses: actions/checkout@v3

    - name: ğŸ“¢ Send Failure Notification
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        BRANCH="${GITHUB_REF#refs/heads/}"
        
        MESSAGE="ğŸš¨ *PIPELINE FALLIDO*%0A%0A"
        MESSAGE="${MESSAGE}âŒ *Estado:* FALLIDO%0A"
        MESSAGE="${MESSAGE}ğŸ“‚ *Rama:* ${BRANCH}%0A"
        MESSAGE="${MESSAGE}ğŸ”§ *Workflow:* ${{ github.workflow }}%0A"
        MESSAGE="${MESSAGE}ğŸ†” *Run ID:* ${{ github.run_id }}%0A%0A"
        MESSAGE="${MESSAGE}âš ï¸ *Se ha detenido el pipeline*%0A"
        MESSAGE="${MESSAGE}ğŸ”— *Revisa los logs para mÃ¡s detalles:*%0A"
        MESSAGE="${MESSAGE}$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"

    - name: ğŸ“ Create Failure Issue
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const branch = '${{ github.ref_name }}';
          const workflow = '${{ github.workflow }}';
          const runId = '${{ github.run_id }}';
          const runUrl = `${{ github.server_url }}/${{ github.repository }}/actions/runs/${runId}`;
          
          const issueBody = `## ğŸš¨ Pipeline Failure Report
          
          ### ğŸ” Details
          - **Branch:** ${branch}
          - **Workflow:** ${workflow}
          - **Run ID:** ${runId}
          - **Status:** âŒ FAILED
          - **Timestamp:** ${new Date().toISOString()}
          
          ### ğŸ”— Links
          - [View Failed Run](${runUrl})
          - [Repository](${{ github.server_url }}/${{ github.repository }})
          
          ### ğŸ› ï¸ Required Action
          1. Check the workflow logs for error details
          2. Fix the issues in the ${branch} branch
          3. Push the fixes
          4. The pipeline will automatically re-run
          
          ### ğŸ“ Notes
          This issue was automatically created by the CI/CD pipeline.`;
          
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `ğŸš¨ Pipeline Failed on ${branch} - Run #${runId}`,
            body: issueBody,
            labels: ['pipeline-failed', 'bug', 'ci-cd', branch]
          });