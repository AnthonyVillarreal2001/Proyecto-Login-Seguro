name: Complete CI/CD Pipeline

on:
  push:
    branches: [dev]
  workflow_dispatch:  # Permite ejecuciÃ³n manual

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  security-analysis:
    name: ğŸ” Security Analysis on Dev
    runs-on: ubuntu-latest
    
    outputs:
      is_safe: ${{ steps.scan.outputs.is_safe }}
      scanned_count: ${{ steps.scan.outputs.scanned_count }}
      commit_sha: ${{ github.sha }}

    steps:
    - name: ğŸ“¦ Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: ğŸ Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"

    - name: ğŸ“¥ Install Python dependencies
      run: |
        pip install -r requirements.txt 2>/dev/null || true
        pip install joblib datasets scikit-learn==1.5.2 scipy requests pandas 2>/dev/null || true

    - name: ğŸ” Security Scan All Files
      id: scan
      run: |
        echo "ğŸ”„ Iniciando escaneo de seguridad completo..."
        echo "ğŸ“‚ Rama actual: ${{ github.ref_name }}"
        
        # Encontrar todos los archivos a analizar
        JS_FILES=$(find . -name "*.js" -not -path "*/node_modules/*" -not -path "*/.next/*" -not -path "*/.venv/*" 2>/dev/null || true)
        PY_FILES=$(find . -name "*.py" -not -path "*/node_modules/*" -not -path "*/.venv/*" -not -path "*/scripts/*" 2>/dev/null || true)
        JAVA_FILES=$(find . -name "*.java" -not -path "*/node_modules/*" -not -path "*/.venv/*" 2>/dev/null || true)
        
        # Combinar archivos
        ALL_FILES=""
        SCANNED_COUNT=0
        VULNERABLE_FILES=""
        FAILED=0
        
        echo "ğŸ“‹ Archivos encontrados:"
        
        # JavaScript files
        for file in $JS_FILES; do
          if [ -f "$file" ]; then
            SCANNED_COUNT=$((SCANNED_COUNT + 1))
            echo "   - $file"
            ALL_FILES="${ALL_FILES}$file"$'\n'
          fi
        done
        
        # Python files
        for file in $PY_FILES; do
          if [ -f "$file" ]; then
            SCANNED_COUNT=$((SCANNED_COUNT + 1))
            echo "   - $file"
            ALL_FILES="${ALL_FILES}$file"$'\n'
          fi
        done
        
        # Java files
        for file in $JAVA_FILES; do
          if [ -f "$file" ]; then
            SCANNED_COUNT=$((SCANNED_COUNT + 1))
            echo "   - $file"
            ALL_FILES="${ALL_FILES}$file"$'\n'
          fi
        done
        
        echo ""
        echo "ğŸ” Total archivos a analizar: $SCANNED_COUNT"
        echo ""
        
        # Analizar cada archivo con tu script de seguridad
        if [ $SCANNED_COUNT -gt 0 ]; then
          echo "ğŸ”¬ Ejecutando anÃ¡lisis de seguridad con ML..."
          
          VULNERABLE_COUNT=0
          
          while IFS= read -r file; do
            if [ -n "$file" ] && [ -f "$file" ]; then
              echo "   Analizando: $(basename "$file")"
              
              # Ejecutar tu script de seguridad
              if python scripts/security_check.py "$file" > /tmp/scan_result.json 2>/dev/null; then
                RESULT=$(cat /tmp/scan_result.json)
                STATUS=$(echo "$RESULT" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('status', 'ERROR'))" 2>/dev/null || echo "ERROR")
                
                if [ "$STATUS" = "VULNERABLE" ]; then
                  VULNERABLE_COUNT=$((VULNERABLE_COUNT + 1))
                  FAILED=1
                  
                  PROB=$(echo "$RESULT" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('probability', 0))" 2>/dev/null || echo "0")
                  LANG=$(echo "$RESULT" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('language', 'Unknown'))" 2>/dev/null || echo "Unknown")
                  FUNCS=$(echo "$RESULT" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('dangerous_functions', '[]'))" 2>/dev/null || echo "[]")
                  OWASP=$(echo "$RESULT" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('owasp_category', 'Unknown'))" 2>/dev/null || echo "Unknown")
                  
                  echo "      âŒ VULNERABLE - Prob: $PROB, Lang: $LANG"
                  VULNERABLE_FILES="${VULNERABLE_FILES}$file|$PROB|$LANG|$FUNCS|$OWASP;"
                elif [ "$STATUS" = "SAFE" ]; then
                  echo "      âœ… SAFE"
                else
                  echo "      âš ï¸  ERROR en anÃ¡lisis"
                fi
              else
                echo "      âš ï¸  No se pudo ejecutar security_check.py"
              fi
            fi
          done <<< "$ALL_FILES"
          
          echo ""
          echo "ğŸ“Š RESULTADO DEL ESCANEO:"
          echo "   Archivos analizados: $SCANNED_COUNT"
          echo "   Vulnerabilidades: $VULNERABLE_COUNT"
          
          if [ $FAILED -eq 0 ]; then
            echo "âœ… TODOS LOS ARCHIVOS SON SEGUROS"
            echo "is_safe=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ SE ENCONTRARON VULNERABILIDADES"
            echo "is_safe=false" >> $GITHUB_OUTPUT
          fi
          
          echo "scanned_count=$SCANNED_COUNT" >> $GITHUB_OUTPUT
          echo "vulnerable_files=$VULNERABLE_FILES" >> $GITHUB_OUTPUT
          
          if [ $FAILED -eq 1 ]; then
            echo "ğŸš« BLOQUEANDO PIPELINE - VULNERABILIDADES DETECTADAS"
            exit 1
          fi
        else
          echo "âš ï¸ No se encontraron archivos para analizar"
          echo "scanned_count=0" >> $GITHUB_OUTPUT
          echo "is_safe=true" >> $GITHUB_OUTPUT
          echo "vulnerable_files=" >> $GITHUB_OUTPUT
        fi

    - name: âœ… Send Telegram - Security Passed
      if: success()
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        MESSAGE="âœ… *Security Analysis PASSED*%0A%0A"
        MESSAGE="${MESSAGE}ğŸ“‚ *Branch:* ${{ github.ref_name }}%0A"
        MESSAGE="${MESSAGE}ğŸ“Š *Files scanned:* ${{ steps.scan.outputs.scanned_count }}%0A"
        MESSAGE="${MESSAGE}ğŸ›¡ï¸ *Status:* ALL SECURE%0A%0A"
        MESSAGE="${MESSAGE}ğŸ”„ *Next:* Merging to test branch"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"

    - name: ğŸš¨ Send Telegram - Security Failed
      if: failure() && github.job == 'security-analysis'
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        VULNERABLE_FILES="${{ steps.scan.outputs.vulnerable_files }}"
        VULN_COUNT=$(echo "$VULNERABLE_FILES" | tr ';' '\n' | grep -c "|")
        
        MESSAGE="ğŸš¨ *Security Analysis FAILED*%0A%0A"
        MESSAGE="${MESSAGE}ğŸ“‚ *Branch:* ${{ github.ref_name }}%0A"
        MESSAGE="${MESSAGE}ğŸ“Š *Files scanned:* ${{ steps.scan.outputs.scanned_count }}%0A"
        MESSAGE="${MESSAGE}âš ï¸ *Vulnerabilities:* $VULN_COUNT%0A"
        MESSAGE="${MESSAGE}ğŸš« *Status:* BLOCKED%0A%0A"
        
        if [ $VULN_COUNT -gt 0 ]; then
          MESSAGE="${MESSAGE}ğŸ“‹ *Vulnerable files:*%0A"
          
          IFS=';' read -ra FILES <<< "$VULNERABLE_FILES"
          for item in "${FILES[@]}"; do
            if [ ! -z "$item" ]; then
              FILE=$(echo "$item" | cut -d'|' -f1)
              PROB=$(echo "$item" | cut -d'|' -f2)
              LANG=$(echo "$item" | cut -d'|' -f3)
              
              PERCENT=$(echo "$PROB * 100" | bc 2>/dev/null || echo "0")
              PERCENT_INT=$(printf "%.0f" $PERCENT 2>/dev/null || echo "0")
              
              MESSAGE="${MESSAGE}%0AğŸ“„ \`$(basename "$FILE")\`%0A"
              MESSAGE="${MESSAGE}   ğŸ”¤ $LANG | âš ï¸ ${PERCENT_INT}%%%0A"
            fi
          done
        fi
        
        MESSAGE="${MESSAGE}%0AğŸ”— *Pipeline blocked. Check logs for details.*"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"

  merge-to-test:
    name: ğŸ”€ Merge Dev to Test
    needs: security-analysis
    runs-on: ubuntu-latest
    if: needs.security-analysis.outputs.is_safe == 'true'

    steps:
    - name: ğŸ“¦ Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: âš™ï¸ Configure Git
      run: |
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "actions@github.com"

    - name: ğŸ”€ Merge dev into test
      run: |
        echo "ğŸ”„ Merging dev to test..."
        
        # Obtener informaciÃ³n del commit
        COMMIT_SHA="${{ needs.security-analysis.outputs.commit_sha }}"
        COMMIT_MSG=$(git log -1 --pretty=%B)
        
        # Hacer merge
        git checkout test
        git pull origin test
        git merge --no-ff dev -m "ğŸ”€ Auto-merge: dev â†’ test [Security Passed]
        
        âœ… Security Analysis:
        - Files scanned: ${{ needs.security-analysis.outputs.scanned_count }}
        - Vulnerabilities: 0
        - Status: SECURE
        
        ğŸ“ Original commit: $COMMIT_MSG
        
        ğŸ”— SHA: ${COMMIT_SHA:0:8}"
        
        git push origin test
        
        echo "âœ… Merge completed successfully!"
        echo "ğŸ”— Test branch updated"

    - name: ğŸ“¢ Send Telegram - Merge Success
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        MESSAGE="âœ… *Merge to Test COMPLETED*%0A%0A"
        MESSAGE="${MESSAGE}ğŸ”„ *From:* dev%0A"
        MESSAGE="${MESSAGE}ğŸ“‚ *To:* test%0A"
        MESSAGE="${MESSAGE}ğŸ“Š *Files scanned:* ${{ needs.security-analysis.outputs.scanned_count }}%0A"
        MESSAGE="${MESSAGE}ğŸ›¡ï¸ *Security status:* SECURE%0A%0A"
        MESSAGE="${MESSAGE}ğŸ§ª *Next:* Running unit tests on test branch"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"

  run-backend-tests:
    name: ğŸ§ª Backend Tests (Node.js)
    needs: merge-to-test
    runs-on: ubuntu-latest

    steps:
    - name: ğŸ“¦ Checkout test branch
      uses: actions/checkout@v3
      with:
        ref: test
        fetch-depth: 0

    - name: ğŸ” Find Backend Directory
      id: find-backend
      run: |
        echo "ğŸ” Searching for backend..."
        
        if [ -d "backend" ] && [ -f "backend/package.json" ]; then
          echo "âœ… Backend found at: backend/"
          echo "directory=backend" >> $GITHUB_OUTPUT
        elif [ -f "package.json" ] && ( [ -f "index.js" ] || [ -f "server.js" ] || [ -f "app.js" ] ); then
          echo "âœ… Backend found at root"
          echo "directory=." >> $GITHUB_OUTPUT
        else
          echo "âš ï¸ Backend not found"
          echo "directory=none" >> $GITHUB_OUTPUT
        fi

    - name: ğŸŸ¢ Setup Node.js
      if: steps.find-backend.outputs.directory != 'none'
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: ${{ steps.find-backend.outputs.directory }}/package.json

    - name: ğŸ“¥ Install Backend Dependencies
      if: steps.find-backend.outputs.directory != 'none'
      run: |
        echo "ğŸ“¦ Installing backend dependencies..."
        cd ${{ steps.find-backend.outputs.directory }}
        npm ci --silent || npm install --silent
        echo "âœ… Dependencies installed"

    - name: ğŸ”§ Show Package.json Info
      if: steps.find-backend.outputs.directory != 'none'
      run: |
        echo "ğŸ“„ Package.json content:"
        cd ${{ steps.find-backend.outputs.directory }}
        cat package.json | grep -A5 -B5 "scripts"

    - name: ğŸ§ª Run Backend Tests (Fixed Detection)
      if: steps.find-backend.outputs.directory != 'none'
      id: backend-tests
      run: |
        echo "ğŸ§ª Running backend tests..."
        cd ${{ steps.find-backend.outputs.directory }}
        
        # Mostrar todos los scripts disponibles
        echo "ğŸ“‹ All available npm scripts:"
        npm run
        
        # Verificar si hay script 'test' de cualquier tipo
        echo ""
        echo "ğŸ” Checking for test scripts..."
        
        # MÃ©todo 1: Buscar 'test' en package.json
        if grep -q '"test"' package.json || grep -q '^  test' package.json; then
          echo "âœ… Test script found in package.json"
          
          # MÃ©todo 2: Ver si npm run test funciona
          if npm run --silent test 2>/dev/null | head -1 | grep -q "jest\|mocha\|test"; then
            echo "ğŸš€ Running npm test..."
            
            # Ejecutar tests con timeout
            timeout 300 npm test 2>&1 | tee test-output.log
            TEST_RESULT=${PIPESTATUS[0]}
            
            if [ $TEST_RESULT -eq 0 ]; then
              echo "âœ… BACKEND TESTS PASSED"
              echo "passed=true" >> $GITHUB_OUTPUT
            elif [ $TEST_RESULT -eq 124 ]; then
              echo "â° TESTS TIMEOUT (5 minutes)"
              echo "passed=false" >> $GITHUB_OUTPUT
              exit 1
            else
              echo "âŒ BACKEND TESTS FAILED"
              echo "ğŸ“„ Test output:"
              cat test-output.log
              echo "passed=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            # MÃ©todo 3: Ejecutar directamente jest
            echo "ğŸ”„ Running Jest directly..."
            if npx jest --passWithNoTests 2>&1 | tee test-output.log; then
              echo "âœ… JEST TESTS PASSED"
              echo "passed=true" >> $GITHUB_OUTPUT
            else
              echo "âŒ JEST TESTS FAILED"
              echo "ğŸ“„ Test output:"
              cat test-output.log
              echo "passed=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
        else
          # MÃ©todo 4: Buscar archivos de test
          echo "ğŸ” Looking for test files..."
          TEST_FILES=$(find . -name "*.test.js" -o -name "*.spec.js" -o -name "test*.js" | head -5)
          
          if [ -n "$TEST_FILES" ]; then
            echo "ğŸ“„ Found test files:"
            echo "$TEST_FILES"
            
            # Intentar con Jest
            echo "ğŸš€ Running tests with Jest..."
            if npx jest --passWithNoTests 2>&1 | tee test-output.log; then
              echo "âœ… TESTS PASSED WITH JEST"
              echo "passed=true" >> $GITHUB_OUTPUT
            else
              # Intentar con Mocha
              echo "ğŸ”„ Trying Mocha..."
              if npx mocha "**/*.test.js" "**/*.spec.js" --exit 2>&1 | tee test-output.log; then
                echo "âœ… TESTS PASSED WITH MOCHA"
                echo "passed=true" >> $GITHUB_OUTPUT
              else
                echo "âŒ NO TEST RUNNER WORKED"
                echo "passed=false" >> $GITHUB_OUTPUT
                exit 1
              fi
            fi
          else
            echo "âš ï¸ No test files or scripts found"
            echo "âœ… Skipping backend tests"
            echo "passed=true" >> $GITHUB_OUTPUT
          fi
        fi

    - name: ğŸ“Š Backend Test Summary
      if: always() && steps.find-backend.outputs.directory != 'none'
      run: |
        echo "ğŸ“ˆ BACKEND TEST SUMMARY"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Directory: ${{ steps.find-backend.outputs.directory }}"
        echo "Status: ${{ steps.backend-tests.outputs.passed == 'true' && 'âœ… PASSED' || 'âŒ FAILED' }}"
        
        if [ -f "${{ steps.find-backend.outputs.directory }}/test-output.log" ]; then
          echo ""
          echo "ğŸ“„ Last 20 lines of test output:"
          tail -20 "${{ steps.find-backend.outputs.directory }}/test-output.log"
        fi

    - name: ğŸ“¢ Send Telegram - Backend Tests
      if: always()
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        if [ "${{ steps.find-backend.outputs.directory }}" = "none" ]; then
          MESSAGE="â„¹ï¸ *Backend Tests SKIPPED*%0A%0A"
          MESSAGE="${MESSAGE}ğŸ“‚ *Reason:* Backend not found%0A"
          MESSAGE="${MESSAGE}ğŸ”— *Branch:* test%0A"
        elif [ "${{ steps.backend-tests.outputs.passed }}" = "true" ]; then
          MESSAGE="âœ… *Backend Tests PASSED*%0A%0A"
          MESSAGE="${MESSAGE}ğŸ“‚ *Location:* ${{ steps.find-backend.outputs.directory }}%0A"
          MESSAGE="${MESSAGE}ğŸ”— *Branch:* test%0A"
          MESSAGE="${MESSAGE}âš¡ *Tests executed successfully*%0A"
        else
          MESSAGE="âŒ *Backend Tests FAILED*%0A%0A"
          MESSAGE="${MESSAGE}ğŸ“‚ *Location:* ${{ steps.find-backend.outputs.directory }}%0A"
          MESSAGE="${MESSAGE}ğŸ”— *Branch:* test%0A"
          MESSAGE="${MESSAGE}âš ï¸ *Check logs for details*%0A"
        fi
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"

  run-frontend-tests:
    name: ğŸ§ª Frontend Tests (React)
    needs: merge-to-test
    runs-on: ubuntu-latest

    steps:
    - name: ğŸ“¦ Checkout test branch
      uses: actions/checkout@v3
      with:
        ref: test
        fetch-depth: 0

    - name: ğŸ” Find Frontend Directory
      id: find-frontend
      run: |
        echo "ğŸ” Searching for frontend..."
        
        if [ -d "frontend" ] && [ -f "frontend/package.json" ]; then
          echo "âœ… Frontend found at: frontend/"
          echo "directory=frontend" >> $GITHUB_OUTPUT
        elif [ -d "client" ] && [ -f "client/package.json" ]; then
          echo "âœ… Frontend found at: client/"
          echo "directory=client" >> $GITHUB_OUTPUT
        elif [ -f "package.json" ]; then
          # Check if it's a React app
          if grep -q "react-scripts" package.json || grep -q "next" package.json || grep -q "react" package.json; then
            echo "âœ… Frontend found at root"
            echo "directory=." >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Frontend not found (no React detected)"
            echo "directory=none" >> $GITHUB_OUTPUT
          fi
        else
          echo "âš ï¸ Frontend not found"
          echo "directory=none" >> $GITHUB_OUTPUT
        fi

    - name: ğŸŸ¢ Setup Node.js
      if: steps.find-frontend.outputs.directory != 'none'
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: ${{ steps.find-frontend.outputs.directory }}/package.json

    - name: ğŸ“¥ Install Frontend Dependencies
      if: steps.find-frontend.outputs.directory != 'none'
      run: |
        echo "ğŸ“¦ Installing frontend dependencies..."
        cd ${{ steps.find-frontend.outputs.directory }}
        npm ci --silent || npm install --silent
        echo "âœ… Dependencies installed"

    - name: ğŸ§ª Run Frontend Tests
      if: steps.find-frontend.outputs.directory != 'none'
      id: frontend-tests
      run: |
        echo "ğŸ§ª Running frontend tests..."
        cd ${{ steps.find-frontend.outputs.directory }}
        
        # Check if test script exists
        if npm run | grep -q " test "; then
          echo "ğŸš€ Running npm test (CI mode)..."
          
          # Set CI environment
          export CI=true
          
          # Run tests with timeout
          timeout 300 npm test -- --watchAll=false --passWithNoTests 2>&1 | tee test-output.log
          TEST_RESULT=${PIPESTATUS[0]}
          
          if [ $TEST_RESULT -eq 0 ]; then
            echo "âœ… FRONTEND TESTS PASSED"
            echo "passed=true" >> $GITHUB_OUTPUT
          elif [ $TEST_RESULT -eq 124 ]; then
            echo "â° TESTS TIMEOUT (5 minutes)"
            echo "passed=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "âŒ FRONTEND TESTS FAILED"
            echo "ğŸ“„ Last 10 lines of output:"
            tail -10 test-output.log
            echo "passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
        else
          echo "âš ï¸ No test script found in package.json"
          echo "ğŸ“„ Available scripts:"
          npm run
          echo "âœ… Skipping frontend tests"
          echo "passed=true" >> $GITHUB_OUTPUT
        fi

    - name: ğŸ“Š Frontend Test Summary
      if: always() && steps.find-frontend.outputs.directory != 'none'
      run: |
        echo "ğŸ“ˆ FRONTEND TEST SUMMARY"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Directory: ${{ steps.find-frontend.outputs.directory }}"
        echo "Status: ${{ steps.frontend-tests.outputs.passed == 'true' && 'âœ… PASSED' || 'âŒ FAILED' }}"
        
        if [ -f "${{ steps.find-frontend.outputs.directory }}/test-output.log" ]; then
          echo "ğŸ“„ Test output available in: ${{ steps.find-frontend.outputs.directory }}/test-output.log"
        fi

    - name: ğŸ“¢ Send Telegram - Frontend Tests
      if: always()
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        if [ "${{ steps.find-frontend.outputs.directory }}" = "none" ]; then
          MESSAGE="â„¹ï¸ *Frontend Tests SKIPPED*%0A%0A"
          MESSAGE="${MESSAGE}ğŸ“‚ *Reason:* Frontend not found%0A"
          MESSAGE="${MESSAGE}ğŸ”— *Branch:* test%0A"
        elif [ "${{ steps.frontend-tests.outputs.passed }}" = "true" ]; then
          MESSAGE="âœ… *Frontend Tests PASSED*%0A%0A"
          MESSAGE="${MESSAGE}ğŸ“‚ *Location:* ${{ steps.find-frontend.outputs.directory }}%0A"
          MESSAGE="${MESSAGE}ğŸ”— *Branch:* test%0A"
        else
          MESSAGE="âŒ *Frontend Tests FAILED*%0A%0A"
          MESSAGE="${MESSAGE}ğŸ“‚ *Location:* ${{ steps.find-frontend.outputs.directory }}%0A"
          MESSAGE="${MESSAGE}ğŸ”— *Branch:* test%0A"
          MESSAGE="${MESSAGE}âš ï¸ *Check logs for details*%0A"
        fi
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"

  merge-to-main:
    name: ğŸš€ Merge Test to Main
    needs: [run-backend-tests, run-frontend-tests]
    runs-on: ubuntu-latest
    if: |
      (needs.run-backend-tests.result == 'success' || needs.run-backend-tests.result == 'skipped') &&
      (needs.run-frontend-tests.result == 'success' || needs.run-frontend-tests.result == 'skipped')

    steps:
    - name: ğŸ“¦ Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: âš™ï¸ Configure Git
      run: |
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "actions@github.com"

    - name: ğŸ”€ Merge test into main
      run: |
        echo "ğŸš€ Merging test to main..."
        
        # Obtener informaciÃ³n actual
        git checkout test
        LATEST_COMMIT=$(git log -1 --pretty=format:"%H")
        LATEST_MSG=$(git log -1 --pretty=format:"%B")
        
        # Crear mensaje de merge
        MERGE_MSG="ğŸš€ Auto-merge: test â†’ main [Pipeline Successful]
        
        ğŸ“Š PIPELINE RESULTS:
        
        ğŸ” SECURITY ANALYSIS:
        - Status: âœ… PASSED
        - Files scanned: ${{ needs.security-analysis.outputs.scanned_count }}
        
        ğŸ§ª UNIT TESTS:
        - Backend: ${{ needs.run-backend-tests.result == 'success' && 'âœ… PASSED' || 'âš ï¸ SKIPPED' }}
        - Frontend: ${{ needs.run-frontend-tests.result == 'success' && 'âœ… PASSED' || 'âš ï¸ SKIPPED' }}
        
        ğŸ“¦ DEPLOYMENT INFO:
        - Source branch: test
        - Target branch: main
        - Pipeline run: #${{ github.run_id }}
        - Timestamp: $(date '+%Y-%m-%d %H:%M:%S')
        
        ğŸ”— Original commit: ${LATEST_COMMIT:0:8}
        ${LATEST_MSG}"
        
        # Realizar merge
        git checkout main
        git pull origin main
        git merge --no-ff test -m "$MERGE_MSG"
        
        # Push a main
        git push origin main
        
        # Crear tag
        TAG_NAME="release-v$(date '+%Y%m%d.%H%M%S')"
        git tag -a "$TAG_NAME" -m "Production release - Pipeline #${{ github.run_id }}"
        git push origin "$TAG_NAME"
        
        echo "âœ… Merge completed!"
        echo "ğŸ·ï¸ Tag created: $TAG_NAME"

    - name: ğŸ‰ Send Telegram - Deployment Success
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        TAG_NAME="release-v$(date '+%Y%m%d.%H%M%S')"
        
        MESSAGE="ğŸ‰ *DEPLOYMENT SUCCESSFUL!*%0A%0A"
        MESSAGE="${MESSAGE}ğŸš€ *Complete CI/CD Pipeline FINISHED*%0A"
        MESSAGE="${MESSAGE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%0A%0A"
        MESSAGE="${MESSAGE}ğŸ“Š *SUMMARY:*%0A"
        MESSAGE="${MESSAGE}ğŸ” *Security Analysis:* âœ… PASSED%0A"
        MESSAGE="${MESSAGE}   â”œâ”€ Files scanned: ${{ needs.security-analysis.outputs.scanned_count }}%0A"
        MESSAGE="${MESSAGE}   â””â”€ Vulnerabilities: 0%0A"
        MESSAGE="${MESSAGE}ğŸ§ª *Unit Tests:*%0A"
        MESSAGE="${MESSAGE}   â”œâ”€ Backend: ${{ needs.run-backend-tests.result == 'success' && 'âœ… PASSED' || 'âš ï¸ SKIPPED' }}%0A"
        MESSAGE="${MESSAGE}   â””â”€ Frontend: ${{ needs.run-frontend-tests.result == 'success' && 'âœ… PASSED' || 'âš ï¸ SKIPPED' }}%0A"
        MESSAGE="${MESSAGE}ğŸ“¦ *Deployment:*%0A"
        MESSAGE="${MESSAGE}   â”œâ”€ From: test%0A"
        MESSAGE="${MESSAGE}   â”œâ”€ To: main âœ…%0A"
        MESSAGE="${MESSAGE}   â””â”€ Tag: ${TAG_NAME}%0A%0A"
        MESSAGE="${MESSAGE}ğŸ *STATUS:* âœ… PRODUCTION READY%0A"
        MESSAGE="${MESSAGE}ğŸ”— *View commit:* $GITHUB_SERVER_URL/$GITHUB_REPOSITORY/commit/${{ github.sha }}"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"

  handle-failure:
    name: ğŸš¨ Handle Pipeline Failure
    runs-on: ubuntu-latest
    if: failure()
    
    steps:
    - name: ğŸ“¢ Send Failure Notification
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        MESSAGE="ğŸš¨ *PIPELINE FAILED*%0A%0A"
        MESSAGE="${MESSAGE}âŒ *Status:* FAILED%0A"
        MESSAGE="${MESSAGE}ğŸ“‚ *Branch:* ${{ github.ref_name }}%0A"
        MESSAGE="${MESSAGE}ğŸ†” *Run ID:* ${{ github.run_id }}%0A"
        MESSAGE="${MESSAGE}ğŸ”§ *Workflow:* ${{ github.workflow }}%0A%0A"
        MESSAGE="${MESSAGE}âš ï¸ *Pipeline has been stopped*%0A"
        MESSAGE="${MESSAGE}ğŸ”— *Check logs:*%0A"
        MESSAGE="${MESSAGE}$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"
        
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=Markdown"